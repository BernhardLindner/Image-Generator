/*
 * FILE = MAIN:       /src/ImageWriter.c
 *
 * RELATED FILES:     *.c                              *.h
 *                    generateKey.c                    generateKey.h
 *                    numberOfPixel.c                  numberOfPixel.h
 *                    cleanupWriter.c                  cleanupWriter.h
 *                    cntrl_c_handler_Writer.c         cntrl_c_handler_Writer.h
 *                    install_signal_handler.C         install_signal_handler.h
 *                    global_ids_W.c                   global_ids_W.h
 *                                                     universalSettings.h
 *
 * DEPENDS ON:        pixelGenerator program
 *
 * A program that continuously writes images generated by the pixelGenerator
 * program into a p6 ppm file.
 *
 * Copyright (c) 2016 Bernhard Lindner
 *
 * This file is licensed under the terms of the MIT License.
 * See /LICENSE for details.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <signal.h>
#include <unistd.h>

#include "numberOfPixel.h"
#include "generateKey.h"
#include "cleanupWriter.h"
#include "cntrl_c_handler_Writer.h"
#include "install_signal_handler.h"
#include "universalSettings.h"
#include "global_ids_W.h"

int main(int argc, char *argv[])
{
  if (argc > 1)
  {
    if ((strncmp(argv[1], "help", 4) == 0) || (strncmp(argv[1], "-h", 2) == 0))
    {
      printf("\nThis program reads image data (RGB pixels) out of an shared\n"
             "memory segment and writes pictures into p6 .ppm file.\n"
             "This program depends on the pixelGenerator program generating\n"
             "image data and writing it into a shared memory segment\n"
             "\nThis program does not take any cmdline arguments.\n\n");
      exit(EXIT_SUCCESS);
    }
    else
    {
      printf("\nThis program does not take any cmdline arguments.\n\n");
      exit(EXIT_FAILURE);
    }
  }

/*
 * Initalize values for global variables (declared in global_ids_W.h)
 * to determine if a segment should be freed or removed from inside
 * the cleanupW() function.
 */

  g_shmid = -1;
  g_semid = -1;
  g_membuf = NULL;
  g_buffer = NULL;
  g_name = NULL;
  g_pIMAGE = NULL;

/*---------------------------------------------------------------------------*/
/* I N S T A L L  S I G N A L  H A N D L E R                                 */
/*---------------------------------------------------------------------------*/

  if (init_signal_handler(SIGINT, cntrl_c_handler_W) == EXIT_FAILURE)
  {
    printf("Error Installing Singnal Handler\n");
    return EXIT_FAILURE;
  }

/*---------------------------------------------------------------------------*/
/* C H E C K  I F  S H A R E D  M E M O R Y  S E G M E N T  E X I S T S      */
/*---------------------------------------------------------------------------*/

  key_t key = -1;
  int nosharedmem = 0;

/*
 * The generateKey() functions is defined in generateKey.c
 * This function is used by the imageWriter and pixelGenerator to receive a key.
 */

  key = generateKey();
  if (key == -1)
  {
    printf("Error generating key\n");
    return EXIT_FAILURE;
  }

/*
 * Checking if the shared memory segment exists. The shared memory segment is
 * created by the pixelGenerator program and therefore depends on the
 * pixelGenerator programing running.
 * If the pixelGenerator has not been started the ImageWriter tries to access
 * the shared memory segment for about 10 seconds and then terminates if the
 * pixelGenerator does not get started in time.
 */

  if ((g_shmid = shmget(key, MAX_DATA, 0)) < 0)
  {
    if (errno == ENOENT)
    {
      printf("\nShared Memory Segment does not exist\n");
      printf("Please start the pixelGenerator program\n");
      printf("Otherwise this program will terminate in 10 seconds\n");
      nosharedmem = 1;
      if (sleep(1) != 0)
      {
        perror("sleep");
        return EXIT_FAILURE;
      }
      printf("\x1B[1;1H\x1B[2J");
    }
    else
    {
      perror("shmget");
      return EXIT_FAILURE;
    }
  }
  if (nosharedmem == 1)
  {
    int counter = 10;

    while (counter != 0)
    {
      if ((g_shmid = shmget(key, MAX_DATA, 0)) < 0)
      {
        if (errno == ENOENT)
        {
          if (counter == 1)
          {
            printf("Shared Memory Segment does not exist\n");
            return EXIT_FAILURE;
          }
        }
        else
        {
          perror("shmget");
          return EXIT_FAILURE;
        }
      }
      else
      {
        break;
      }
      counter--;
      if (sleep(1) != 0)
      {
        perror("sleep");
        return EXIT_FAILURE;
      }
    }
    printf("pixelGenerator has been started!\n");
  }

/*
 * Attaching the global pointer unsigend char* g_membuf to
 * the shared memory segment. The variable is global to be able to access it
 * from inside the signal handler and detach it from the shared segment
 * when the program terminates.
 */

  g_membuf = shmat(g_shmid, 0, 0);
  if (g_membuf == (unsigned char *) -1)
  {
    perror("shmat");
    cleanupW();
    return EXIT_FAILURE;
  }

/*---------------------------------------------------------------------------*/
/* C H E C K  F O R  E X I S T I N G  S E M A P H O R E S                    */
/*---------------------------------------------------------------------------*/

/*
 * Both semaphores are created and removed by the pixelGenerator program.
 */

  if ((g_semid = semget(key, 2 ,0)) < 0)
  {
    if (errno == ENOENT)
    {
      printf("Semaphore does not exist\n");
      cleanupW();
      return EXIT_FAILURE;
    }
    else
    {
      perror("semget");
      cleanupW();
      return EXIT_FAILURE;
    }
  }

/*
 * prepare semaphore flags
 */

  struct sembuf s1;
  struct sembuf s2;

  s1.sem_num = 0;
  s1.sem_flg = SEM_UNDO;

  s2.sem_num = 1;
  s2.sem_flg = SEM_UNDO;

/*---------------------------------------------------------------------------*/
/* G E N E R A T E  L O C A L  I M A G E  B U F F E R                        */
/*---------------------------------------------------------------------------*/

/*
 * After reading from the shared memory segment the image data is stored inside
 * a local buffer before the content of the buffer gets written to a ppm file.
 */

  g_buffer = (unsigned char *) calloc(MAX_DATA, sizeof(unsigned char));
  if (g_buffer == NULL)
  {
    cleanupW();
    perror("calloc");
    return EXIT_FAILURE;
  }
/*---------------------------------------------------------------------------*/
/* R E A D  F R O M  S H A R E D  M E M O R Y                                */
/*---------------------------------------------------------------------------*/

/*
 * Initalize values for image name. Allocate memory for the imagename.
 */

  int imagenumber = 1;
  int maxname = 14;
  int maxnumber = 1000;
  g_name = (char *) malloc(maxname * sizeof(char));
  if (g_name == NULL)
  {
    cleanupW();
    perror("malloc");
    return EXIT_FAILURE;
  }

  while(1)
  {

/*
 * lock the ImageWriter semaphore do prevent reading from the shared memory
 * segment while the pixelGenerator is writing to it at the same time.
 */

    s2.sem_op = -1;

    if (semop(g_semid, &s2, 1) == -1)
    {
      if (errno == EIDRM)
      {
        printf("\nSemaphore has been removed\n");
        printf("Check if the pixelGenerator program has terminated\n\n");
      }
      else
      {
        perror("semop");
      }
      cleanupW();
      return EXIT_FAILURE;
    }

/*
 * Read data from shared memory into the local buffer
 */

    for (int i = 0; i < MAX_DATA; i++)
    {
        g_buffer[i] = g_membuf[i];
    }
/*
 * Unlock the pixelGenerator semaphore to allow the pixelGenerator to write to
 * the shared memory segment.
 */

    s1.sem_op = 1;

    if (semop(g_semid, &s1, 1) == -1)
    {
      if (errno == EIDRM)
      {
        printf("\nSemaphore has been removed.\n");
        printf("Check if the pixelGenerator program has terminated\n\n");
      }
      else
      {
        perror("semop");
      }
      cleanupW();
      return EXIT_FAILURE;
    }

/*---------------------------------------------------------------------------*/
/* W R I T E  I M A G E  T O  F I L E                                        */
/*---------------------------------------------------------------------------*/

/*
 * Print a sequential number to the imagename.
 */

    if (snprintf(g_name, maxname, "image-%03d.ppm", imagenumber) < 0)
    {
      perror("sprintf");
      cleanupW();
      return EXIT_FAILURE;
    }

    char *COMMENT = "# Mandelbrot set";
    int BITDEPTH = 255;
    g_pIMAGE = NULL;

    g_pIMAGE = fopen(g_name, "wb");
    if (g_pIMAGE == NULL)
    {
      printf("Could not open file.");
      cleanupW();
      return EXIT_FAILURE;
    }

/*
 * Print a header to the image file.
 */

    if (fprintf(g_pIMAGE,"P6\n%s\n%d %d\n%d\n", COMMENT, WIDTH, HEIGHT,
        BITDEPTH) < 0)
    {
      perror("fprintf");
      cleanupW();
      return EXIT_FAILURE;
    }

/*
 * Write the local buffer to the image file.
 */

    if (fwrite(g_buffer , 1 , MAX_DATA, g_pIMAGE) != MAX_DATA)
    {
      printf("Error writing image data to file\n");
      cleanupW();
      return EXIT_FAILURE;
    }

    if (g_pIMAGE != NULL)
    {
      if (fclose(g_pIMAGE) == 0)
      {
        g_pIMAGE = NULL;
      }
      else
      {
        printf("Error: IMAGE File could not be closed.\n");
        cleanupW();
        return EXIT_FAILURE;
      }
    }

    imagenumber++;

/*
 * Check if the imagenumber "is to big for the imagename" and if necessary
 * realloc more memory for the imagename.
 */

    if (imagenumber == maxnumber)
    {
      maxname = maxname + 1;
      maxnumber = (maxnumber * 10);
      char *temp = (char *) realloc(g_name, maxname * sizeof(char));
      if (temp == NULL)
      {
        perror("realloc");
        cleanupW();
        return EXIT_FAILURE;
      }
      g_name = temp;
    }
  }
  return EXIT_SUCCESS;
}
