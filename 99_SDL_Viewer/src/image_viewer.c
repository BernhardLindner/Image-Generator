/*
 * DEPENDS ON:      pixelGenerator program
 *
 * A program that continuously shows images generated by the pixelGenerator
 * using libSDL
 *
 * 05/2016 Bernhard Lindner
 * 11/2016, 01/2017 Christian Fibich
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <signal.h>
#include <unistd.h>
#include <SDL.h>

#include "numberOfPixel.h"
#include "generateKey.h"

/* SHM/SEM globals */
int g_shmid;
int g_semid;
unsigned char *g_buffer;
unsigned char *g_membuf;

/* SDL globals */

SDL_Surface *g_surface = NULL,*g_screen = NULL;
SDL_Window *g_window = NULL;
    
/* free buffers */
static void cleanup(void)
{
    SDL_FreeSurface(g_surface);
    g_surface = NULL;
    
    free(g_buffer);
    g_buffer = NULL;

    if (g_membuf != NULL) {
        if (shmdt(g_membuf) < 0) {
            perror("shmdt");
        }
    }
    
    if (g_window != NULL) SDL_DestroyWindow(g_window); /* don't need to destroy non-existent window */
    g_window = NULL;
    
    SDL_Quit();
}

static void sigint_handler(int signum)
{
    (void)signum;
    cleanup();
    exit(EXIT_SUCCESS);
}

int main(int argc, char *argv[])
{
    if (argc > 1) {
        printf("Usage: %s\n",argv[0]);
        if ((strncmp(argv[1], "help", 4) == 0) || (strncmp(argv[1], "-h", 2) == 0)) {
            printf("\nThis program reads image data (RGB pixels) out of an shared\n"
                   "memory segment and writes pictures into p6 .ppm file.\n"
                   "This program depends on the pixelGenerator program generating\n"
                   "image data and writing it into a shared memory segment\n"
                   "\nThis program does not take any cmdline arguments.\n\n");
            exit(EXIT_SUCCESS);
        } else {
            fprintf(stderr,"\nThis program does not take any cmdline arguments.\n\n");
            exit(EXIT_FAILURE);
        }
    }

    /*
     * SDL Setup
     */
    SDL_Event e;

    Uint32 rmask, gmask, bmask, amask;

    rmask = 0x00ff0000;
    gmask = 0x0000ff00;
    bmask = 0x000000ff;
    amask = 0x00000000;

    /* FIXME: Valgrind says some of the memory allocated here (through X11)
     *        is leaked when leaving via SIGINT or by closing the window
     *        Our bug? SDL bug? X11 bug?
     *        Might be http://stackoverflow.com/a/23148969
     */
    if(SDL_Init(SDL_INIT_VIDEO) < 0) {
        fprintf(stderr,"%s: SDL_Init failed: %s\n", argv[0], SDL_GetError());
        exit(EXIT_FAILURE);
    }

    g_window = SDL_CreateWindow(
                 "Mandelbrot Demo Image Viewer",    // window title
                 SDL_WINDOWPOS_UNDEFINED,           // initial x position
                 SDL_WINDOWPOS_UNDEFINED,           // initial y position
                 WIDTH,                             // width, in pixels
                 HEIGHT,                            // height, in pixels
                 SDL_WINDOW_OPENGL                  // flags
             );
    if (g_window == NULL) {
        fprintf(stderr,"%s: SDL_CreateWindow failed: %s\n", argv[0], SDL_GetError());
        SDL_Quit();
        exit(EXIT_FAILURE);
    }

    /*
     * Initalize values for global variables (declared in global_ids_W.h)
     * to determine if a segment should be freed or removed from inside
     * the cleanup() function.
     */

    g_shmid = -1;
    g_semid = -1;
    g_membuf = NULL;
    g_buffer = NULL;

    /*---------------------------------------------------------------------------*/
    /* I N S T A L L  S I G N A L  H A N D L E R                                 */
    /*---------------------------------------------------------------------------*/

    struct sigaction act;
    // siginfo_t signalinfo;
    memset(&act, 0, sizeof(struct sigaction));

    act.sa_flags = 0;
    sigemptyset(&act.sa_mask);

    /*
     * The sigint_handler function is defined in sigint_handler.
     * If a SIGINT signal is sent by pressing ctrl+c this function invokes the
     * cleanup() function and termiates the program.
     */

    act.sa_handler = sigint_handler;
    // act.sa_sigaction((int) sigint_handler, &signalinfo, NULL);


#if OS_FEDORA
    /*
     * sa_restorer is not part of struct sigaction on osx.
     */

    act.sa_restorer = NULL;
#endif

    if ((sigaction(SIGINT, &act, NULL)) < 0) {
        fprintf(stderr,"%s: sigaction(): %s\n",argv[0], strerror(errno));
        cleanup();
        exit(EXIT_FAILURE);
    }

    /*---------------------------------------------------------------------------*/
    /* C H E C K  I F  S H A R E D  M E M O R Y  S E G M E N T  E X I S T S      */
    /*---------------------------------------------------------------------------*/

    key_t key = -1;
    int nosharedmem = 0;

    /*
     * The generateKey() functions is defined in generateKey.c
     * This function is used to recieve a key by the imageWriter an pixelGenerator
     */

    key = generateKey();
    if (key == -1) {
        fprintf(stderr,"%s: generateKey()\n",argv[0]);
        cleanup();
        exit(EXIT_FAILURE);
    }

    /*
     * Checking if the shared memory segment exists. The shared memory segment is
     * created by the pixelGenerator program and therefore dpends on the
     * pixelGenerator programing running.
     * If the pixelGenerator has not been started the ImageWriter tries to access
     * the shared memory segment for about 10 seconds and then terminates if the
     * pixelGenerator does not get started in time.
     */

    if ((g_shmid = shmget(key, MAX_DATA, 0)) < 0) {
        if (errno == ENOENT) {
            printf("\nShared Memory Segment does not exist\n");
            printf("Please start the pixelGenerator program\n");
            printf("Otherwise this program will terminate in 10 seconds\n");
            nosharedmem = 1;
            if (sleep(1) != 0) {
                fprintf(stderr,"%s: sleep(): %s\n",argv[0], strerror(errno));
                cleanup();
                exit(EXIT_FAILURE);
            }
            printf("\x1B[1;1H\x1B[2J");
        } else {
            fprintf(stderr,"%s: shmemget(): %s\n",argv[0], strerror(errno));
            cleanup();
            exit(EXIT_FAILURE);
        }
    }
    if (nosharedmem == 1) {
        int counter = 10;

        while (counter != 0) {
            if ((g_shmid = shmget(key, MAX_DATA, 0)) < 0) {
                if (errno == ENOENT) {
                    if (counter == 1) {
                        fprintf(stderr,"%s: Shared Memory Segment does not exist\n",argv[0]);
                        cleanup();
                        exit(EXIT_FAILURE);
                    }
                } else {
                    fprintf(stderr,"%s: shmget(): %s\n",argv[0],strerror(errno));
                    cleanup();
                    exit(EXIT_FAILURE);
                }
            } else {
                break;
            }
            counter--;
            if (sleep(1) != 0) {
                fprintf(stderr,"%s: sleep(): %s\n",argv[0], strerror(errno));
                cleanup();
                exit(EXIT_FAILURE);
            }
        }
        printf("pixelGenerator has been started!\n");
    }

    /*
     * Attaching the global pointer unsigend char* g_membuf to
     * the shared memory segment. The variable is global to be able to access it
     * from inside the signal handler and detach it from the shared segment
     * when the program terminates
     */

    g_membuf = shmat(g_shmid, 0, 0);
    if (g_membuf == (unsigned char *) -1) {
        fprintf(stderr,"%s: sleep(): %s\n",argv[0], strerror(errno));
        cleanup();
        exit(EXIT_FAILURE);
    }

    /*---------------------------------------------------------------------------*/
    /* C H E C K  F O R  E X I S T I N G  S E M A P H O R E S                    */
    /*---------------------------------------------------------------------------*/

    /*
     * Both semaphores are created and removed by the pixelGenerator program.
     */

    if ((g_semid = semget(key, 2 ,0)) < 0) {
        fprintf(stderr,"%s: semget(): %s\n",argv[0], strerror(errno));
        cleanup();
        exit(EXIT_FAILURE);
    }

    /*
     * prepare semaphore flags
     */

    struct sembuf s1;
    struct sembuf s2;

    s1.sem_num = 0;
    s1.sem_flg = SEM_UNDO;

    s2.sem_num = 1;
    s2.sem_flg = SEM_UNDO;

    /*---------------------------------------------------------------------------*/
    /* R E A D  F R O M  S H A R E D  M E M O R Y                                */
    /*---------------------------------------------------------------------------*/

    /*
     * Initalize values for image name. Allocate memory for the imagename.
     */

    int imagenumber = 1;

    while(1) {

        /*
         * lock the ImageWriter semaphore do prevent reading from the shared memory
         * segment while the pixelGenerator is writing to it at the same time.
         */

        s2.sem_op = -1;

        if (semop(g_semid, &s2, 1) == -1) {
            int rv = EXIT_FAILURE;
            if (errno == EIDRM) {
                printf("\nSemaphore has been removed\n");
                printf("Check if the pixelGenerator program has terminated\n\n");
                rv = EXIT_SUCCESS;
            } else {
                fprintf(stderr,"%s: semop(): %s\n",argv[0], strerror(errno));
            }
            cleanup();
            exit(rv);
        }
        /*
         * S D L   S U R F A C E
         */
        g_surface = SDL_CreateRGBSurface(SDL_SWSURFACE, WIDTH, HEIGHT, 32,
                                       rmask, gmask, bmask, amask);
        if(g_surface == NULL) {
            fprintf(stderr, "CreateRGBSurface failed: %s\n", SDL_GetError());
            cleanup();
            exit(EXIT_FAILURE);
        }
        uint32_t *image = g_surface->pixels;

        /*
         * Read from shared memory into the local buffer
         */

        for (int i = 0; i < WIDTH*HEIGHT; i++) {
            image[i] = (g_membuf[i*3] << 16) | (g_membuf[i*3+1] << 8) | (g_membuf[i*3+2]) ;
        }

        /*
         * Unlock the pixelGenerator semaphore to allow the pixelGenerator to write to
         * the shared memory segment.
         */
        s1.sem_op = 1;

        if (semop(g_semid, &s1, 1) == -1) {
            int rv = EXIT_FAILURE;
            if (errno == EIDRM) {
                printf("\nSemaphore has been removed\n");
                printf("Check if the pixelGenerator program has terminated\n\n");
                rv = EXIT_SUCCESS;
            } else {
                fprintf(stderr,"%s: semop(): %s\n",argv[0], strerror(errno));
            }
            cleanup();
            exit(rv);
        }

        /*---------------------------------------------------------------------------*/
        /* W R I T E  I M A G E  T O  S D L                                          */
        /*---------------------------------------------------------------------------*/

        printf("Displaying image %d.\n",imagenumber);

        g_screen = SDL_GetWindowSurface(g_window);
        SDL_BlitSurface(g_surface, NULL, g_screen, NULL);
        SDL_FreeSurface(g_surface);
        g_surface = NULL;
        SDL_UpdateWindowSurface(g_window);

        //Handle events on queue
        while( SDL_PollEvent( &e ) != 0 ) {
            //User requests quit
            if( e.type == SDL_QUIT ) {
                goto END;
            }
        }

        imagenumber++;

    }

END:

    cleanup();

    return EXIT_SUCCESS;
}
